// netlify/functions/generateStatements.js
// Accepts JSON { framework, companyName, notes, files:[{kind,name,mimeType,base64}] }
// Sends a multimodal request (text + base64 files) to Gemini using @google/genai.
// NOTE: We DO NOT decode base64. We pass it via inlineData to Gemini.

import { GoogleGenAI } from "@google/genai";

function json(statusCode, obj) {
  return {
    statusCode,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(obj),
  };
}

function buildPrompt({ framework, companyName, notes }) {
  return `
You are an expert ${framework} financial reporting assistant.
Using the uploaded documents (prior-year PDF and/or current-year trial balance in Excel),
generate a professional draft of the current-year financial statements for "${companyName || "the company"}".
Reflect the structure and tone of the prior report when present. Map amounts from the trial balance where possible.
Clearly flag any missing disclosures required by ${framework}.

User notes:
${notes || "(none)"}

Output sections:
1) Statement of Profit or Loss (with comparatives)
2) Statement of Financial Position (with comparatives)
3) Key accounting policies (brief)
4) Key notes (revenue, leases, instruments, PPE/intangibles)
5) Missing disclosures list
`.trim();
}

const ALLOWED = new Set([
  "application/pdf",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
]);

// Guess mime if browser didn’t set one
function guessMime(name = "") {
  const n = name.toLowerCase();
  if (n.endsWith(".pdf")) return "application/pdf";
  if (n.endsWith(".xls")) return "application/vnd.ms-excel";
  if (n.endsWith(".xlsx")) return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
  return "";
}

export async function handler(event) {
  try {
    if (event.httpMethod !== "POST") return json(405, { error: "Method Not Allowed" });

    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) return json(500, { error: "Missing GEMINI_API_KEY" });

    const modelName = process.env.GEMINI_MODEL || "gemini-2.5-flash";

    let body = {};
    try {
      body = JSON.parse(event.body || "{}");
    } catch {
      return json(400, { error: "Invalid JSON body" });
    }

    const { framework = "IFRS", companyName = "", notes = "", files = [] } = body;

    if (!Array.isArray(files)) return json(400, { error: "`files` must be an array" });
    if (files.length === 0) return json(400, { error: "Please include at least one file in base64" });

    // Validate & size-check base64 files (do not decode)
    const inlineParts = [];
    let totalApproxBytes = 0;

    for (const f of files) {
      if (!f) continue;
      const name = f.name || "unnamed";
      const mimeType = f.mimeType || guessMime(name);
      const base64 = typeof f.base64 === "string" ? f.base64.replace(/\s+/g, "") : "";

      if (!base64) return json(400, { error: `Missing base64 for file: ${name}` });
      if (!mimeType || !ALLOWED.has(mimeType)) {
        return json(400, { error: `Unsupported file type for ${name}: ${mimeType || "unknown"}. Upload PDF or Excel.` });
      }
      // Quick integrity check: base64 length often divisible by 4
      if (base64.length % 4 !== 0) {
        return json(400, {
          error: `The uploaded base64 for ${name} looks incomplete (length not multiple of 4).`,
          details: "This often happens when the file is too large for a single request and got truncated by the server. Try a smaller file (≤ 8–9 MB) or split the PDF.",
        });
      }

      // Approx decoded size
      const approxBytes = Math.round((base64.length * 3) / 4);
      totalApproxBytes += approxBytes;

      if (totalApproxBytes > 10 * 1024 * 1024) {
        return json(400, {
          error: `Total upload too large (~${(totalApproxBytes/1024/1024).toFixed(2)} MB).`,
          details: "Netlify Functions requests are limited (≈10 MB). Please compress your PDF, upload only key pages, or reduce file size.",
        });
      }

      inlineParts.push({
        inlineData: { mimeType, data: base64 }
      });
    }

    if (inlineParts.length === 0) {
      return json(400, { error: "No valid files after validation (PDF/Excel only)." });
    }

    const prompt = buildPrompt({ framework, companyName, notes });

    const genAI = new GoogleGenAI({ apiKey });
    // Build contents manually (no createPartFromBuffer)
    const contents = [{
      role: "user",
      parts: [
        { text: prompt },
        ...inlineParts
      ]
    }];

    const response = await genAI.models.generateContent({ model: modelName, contents });
    const text = response?.text?.();
    if (!text) return json(502, { error: "No text generated by Gemini", modelTried: modelName });

    return json(200, { output: text, model: modelName });
  } catch (err) {
    console.error("generateStatements error:", err);
    return json(500, { error: "Gemini request failed", details: err?.message || String(err) });
  }
}







