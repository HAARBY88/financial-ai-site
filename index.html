<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Financial AI Filing Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --brand:#004080; --brand2:#0066cc; --bg:#f4f6f8; --card:#fff; --text:#333; --muted:#777; --err:#b00020; }
    body { font-family: Arial, sans-serif; max-width: 980px; margin: 0 auto; padding: 24px; background: var(--bg); color: var(--text); }
    h1,h2,h3 { color: var(--brand); margin: 0 0 12px; }
    .card { background: var(--card); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,.06); padding: 16px 18px; margin: 16px 0; }
    .row { display: grid; gap: 12px; grid-template-columns: 1fr 1fr; }
    .row > div { display: flex; flex-direction: column; gap: 8px; }
    label { font-weight: 600; }
    input[type="file"], input[type="text"], select, textarea {
      padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background: #fff; width: 100%;
    }
    textarea { min-height: 96px; resize: vertical; }
    button { background: var(--brand); color: #fff; border: 0; border-radius: 10px; padding: 10px 14px; cursor: pointer; font-weight: 600; }
    button:hover { background: var(--brand2); }
    .muted { color: var(--muted); }
    .loading { color: #555; }
    .err { color: var(--err); white-space: pre-wrap; }
    pre { background: #f7f7f7; border: 1px solid #eee; border-radius: 8px; padding: 12px; white-space: pre-wrap; overflow-x: auto; }
    .footer-note { font-size: 12px; color: var(--muted); margin-top: 8px; }
  </style>
</head>
<body>
  <h1>Financial AI Filing Analysis</h1>

  <!-- Section 0: Context -->
  <div class="card">
    <h2>0) Context</h2>
    <div class="row">
      <div>
        <label for="companyName">Company name (optional)</label>
        <input id="companyName" type="text" placeholder="e.g., Anglo London Limited" />
      </div>
      <div>
        <label for="framework">Accounting framework</label>
        <select id="framework">
          <option value="IFRS" selected>IFRS</option>
          <option value="US GAAP">US GAAP</option>
        </select>
      </div>
    </div>
    <label for="notes" style="margin-top:10px;">Notes to the assistant (optional)</label>
    <textarea id="notes" placeholder="Anything special to highlight, e.g., restatements, new standards adoption, one-offs…"></textarea>
  </div>

  <!-- Section 1: Prior-year PDF -->
  <div class="card">
    <h2>1) Upload Prior-Year Financial Statements (PDF)</h2>
    <div class="row">
      <div>
        <label for="priorPdf">Prior-year PDF</label>
        <input id="priorPdf" type="file" accept="application/pdf" />
      </div>
      <div style="align-self:end;">
        <button id="btnExtractPrior">Extract Prior-Year Style</button>
      </div>
    </div>
    <div id="priorPreview" class="muted">Preview will appear here…</div>
    <div class="footer-note">We extract just enough text to capture tone, headings and structure.</div>
  </div>

  <!-- Section 3: Trial balances (client-side parsing) -->
  <div class="card">
    <h2>3) Upload Trial Balances (Excel/CSV)</h2>
    <div class="row">
      <div>
        <label for="tbPrior">Prior-year TB (.xlsx/.xls/.csv)</label>
        <input id="tbPrior" type="file" accept=".xlsx,.xls,.csv" />
      </div>
      <div>
        <label for="tbCurrent">Current-year TB (.xlsx/.xls/.csv)</label>
        <input id="tbCurrent" type="file" accept=".xlsx,.xls,.csv" />
      </div>
    </div>
    <div style="margin-top:10px;">
      <button id="btnReadTBs">Read Trial Balances (client-side)</button>
    </div>
    <div id="tbOutput" class="muted" style="margin-top:10px;">TB check will appear here…</div>
  </div>

  <!-- Section 4: Generate -->
  <div class="card">
    <h2>4) Generate Draft Statements</h2>
    <button id="generateBtn">Generate Draft with Gemini</button>
    <div id="aiOutput" class="muted" style="margin-top:10px;">Draft will appear here…</div>
  </div>

  <!-- Diagnostics (optional) -->
  <div class="card">
    <h3>Diagnostics</h3>
    <pre id="diagnostics" class="muted">No actions yet…</pre>
  </div>

  <!-- SheetJS for client-side Excel/CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
  (function () {
    // ---------- Helpers ----------
    const $ = (sel) => document.querySelector(sel);
    const setHTML = (sel, html, cls) => {
      const el = $(sel);
      if (!el) return;
      if (cls !== undefined) el.className = cls;
      el.innerHTML = html;
    };

    function savePriorText(txt) { sessionStorage.setItem("priorText", txt || ""); }
    function loadPriorText() { return sessionStorage.getItem("priorText") || ""; }
    function saveTbParsed(obj) { sessionStorage.setItem("tbParsed", JSON.stringify(obj || {})); }
    function loadTbParsed() {
      const raw = sessionStorage.getItem("tbParsed") || "";
      try { return raw ? JSON.parse(raw) : {}; } catch { return {}; }
    }

    function readAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Failed to read file"));
        fr.onload = () => resolve(fr.result);
        fr.readAsArrayBuffer(file);
      });
    }
    function readAsText(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Failed to read file"));
        fr.onload = () => resolve(fr.result);
        fr.readAsText(file);
      });
    }
    function toBase64(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Failed to read file"));
        fr.onload = () => resolve(String(fr.result).split(",")[1] || "");
        fr.readAsDataURL(file);
      });
    }

    // CSV + XLSX parsing (client-side)
    function parseCSVText(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
      if (!lines.length) return {};
      const rows = lines.map(l => l.split(",").map(s => s.replace(/^"|"$/g, "").trim()));
      // Heuristic: first col = name, find numeric-ish column for amount
      let amtIdx = 1, bestScore = -1;
      const maxCols = Math.min(5, rows[0]?.length || 0);
      for (let c = 1; c < maxCols; c++) {
        let score = 0;
        for (let r = 1; r < rows.length; r++) {
          const v = rows[r][c];
          if (typeof v === "number") score++;
          else if (typeof v === "string" && v && !isNaN(Number(v.replace(/[, ]/g, "")))) score++;
        }
        if (score > bestScore) { bestScore = score; amtIdx = c; }
      }
      const out = {};
      for (let r = 1; r < rows.length; r++) {
        const name = (rows[r][0] || "").toString().trim();
        if (!name) continue;
        let val = rows[r][amtIdx];
        if (typeof val === "string") val = Number(val.replace(/[, ]/g, ""));
        if (typeof val !== "number" || isNaN(val)) continue;
        out[name] = (out[name] || 0) + val;
      }
      return out;
    }

    function parseWorkbook(ab) {
      const wb = XLSX.read(ab, { type: "array" });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true });
      if (!rows || !rows.length) return {};
      let amtIdx = 1, bestScore = -1;
      const maxCols = Math.min(5, rows[0].length);
      for (let c = 1; c < maxCols; c++) {
        let score = 0;
        for (let r = 1; r < rows.length; r++) {
          const v = rows[r][c];
          if (typeof v === "number") score++;
          else if (typeof v === "string" && v && !isNaN(Number(v.replace(/[, ]/g, "")))) score++;
        }
        if (score > bestScore) { bestScore = score; amtIdx = c; }
      }
      const out = {};
      for (let r = 1; r < rows.length; r++) {
        const name = (rows[r][0] ?? "").toString().trim();
        if (!name) continue;
        let val = rows[r][amtIdx];
        if (typeof val === "string") val = Number(val.replace(/[, ]/g, ""));
        if (typeof val !== "number" || isNaN(val)) continue;
        out[name] = (out[name] || 0) + val;
      }
      return out;
    }

    async function parseTBFile(file) {
      const lower = (file.name || "").toLowerCase();
      if (lower.endsWith(".csv")) {
        const text = await readAsText(file);
        return parseCSVText(text);
      }
      const ab = await readAsArrayBuffer(file);
      return parseWorkbook(ab);
    }

    // ---------- Wire up UI ----------
    const priorPdf = $("#priorPdf");
    const btnExtractPrior = $("#btnExtractPrior");
    const priorPreview = $("#priorPreview");

    const tbPrior = $("#tbPrior");
    const tbCurrent = $("#tbCurrent");
    const btnReadTBs = $("#btnReadTBs");
    const tbOutput = $("#tbOutput");

    const framework = $("#framework");
    const companyName = $("#companyName");
    const notes = $("#notes");
    const btnGenerate = $("#generateBtn");
    const aiOutput = $("#aiOutput");
    const diagnostics = $("#diagnostics");

    // On load: show cached state
    const cachedPrior = loadPriorText();
    if (cachedPrior) {
      setHTML("#priorPreview", `<strong>Extracted preview (cached, first 600 chars):</strong><br><pre>${cachedPrior.slice(0,600)}</pre>`);
    }
    const cachedTB = loadTbParsed();
    if (cachedTB?.prior && cachedTB?.current) {
      setHTML("#tbOutput", `<strong>Cached TB:</strong> prior=${Object.keys(cachedTB.prior).length} lines, current=${Object.keys(cachedTB.current).length} lines`);
    }

    // Section 1: extract prior PDF (calls Netlify function)
    btnExtractPrior.addEventListener("click", async () => {
      try {
        if (!priorPdf.files?.[0]) {
          setHTML("#priorPreview", "⚠️ Please choose a prior-year PDF first.", "err");
          return;
        }
        setHTML("#priorPreview", "⏳ Reading PDF…", "loading");
        const base64 = await toBase64(priorPdf.files[0]);
        setHTML("#priorPreview", "⏳ Extracting text from PDF…", "loading");

        const res = await fetch("/.netlify/functions/extractPriorPdf", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ priorPdfBase64: base64 })
        });

        const raw = await res.text();
        let data = {};
        try { data = JSON.parse(raw); } catch {}

        if (!res.ok) {
          console.error("extractPriorPdf failed:", raw);
          setHTML("#priorPreview", `<span class="err">❌ Extract failed.\n${data.error || raw}</span>`, "err");
          diagnostics.textContent = `extractPriorPdf error:\n${data.error || raw}`;
          return;
        }
        if (!data.text) {
          setHTML("#priorPreview", `<span class="err">❌ No text extracted from PDF.</span>`, "err");
          diagnostics.textContent = "extractPriorPdf: empty text";
          return;
        }
        savePriorText(data.text);
        setHTML("#priorPreview", `<strong>Extracted preview (first 600 chars):</strong><br><pre>${data.text.slice(0,600)}</pre>`);
        diagnostics.textContent = "extractPriorPdf OK";
      } catch (err) {
        console.error("extractPriorPdf exception:", err);
        setHTML("#priorPreview", `<span class="err">❌ ${err.message}</span>`, "err");
        diagnostics.textContent = `extractPriorPdf exception: ${err.message}`;
      }
    });

    // Section 3: read TBs client-side (no server call)
    btnReadTBs.addEventListener("click", async () => {
      try {
        if (!tbPrior.files?.[0] || !tbCurrent.files?.[0]) {
          setHTML("#tbOutput", "⚠️ Please choose both the prior and current TB files.", "err");
          return;
        }
        setHTML("#tbOutput", "⏳ Reading trial balances (client-side)…", "loading");
        const prior = await parseTBFile(tbPrior.files[0]);
        const current = await parseTBFile(tbCurrent.files[0]);
        const totalPrior = Object.values(prior).reduce((a, b) => a + b, 0);
        const totalCurrent = Object.values(current).reduce((a, b) => a + b, 0);
        const tbParsed = { prior, current, totals: { prior: totalPrior, current: totalCurrent } };
        saveTbParsed(tbParsed);
        const sample = {
          samplePrior: Object.entries(prior).slice(0, 5),
          sampleCurrent: Object.entries(current).slice(0, 5)
        };
        setHTML("#tbOutput",
          `<strong>Parsed (client-side):</strong> prior=${Object.keys(prior).length} lines, current=${Object.keys(current).length} lines<br>` +
          `<strong>Totals:</strong> prior=${totalPrior.toLocaleString()}, current=${totalCurrent.toLocaleString()}<br>` +
          `<pre>${JSON.stringify(sample, null, 2)}</pre>`
        );
      } catch (err) {
        console.error("Client TB parse error:", err);
        setHTML("#tbOutput", `<span class="err">❌ ${err.message}</span>`, "err");
      }
    });

    // Section 4: generate draft with Gemini
    btnGenerate.addEventListener("click", async () => {
      try {
        const priorText = loadPriorText();
        const tbParsed = loadTbParsed();
        const errs = [];
        if (!priorText) errs.push("• Upload & extract the prior-year PDF (Section 1).");
        if (!tbParsed || !tbParsed.prior || !tbParsed.current) errs.push("• Upload & read both TB files (Section 3).");
        if (errs.length) {
          setHTML("#aiOutput", `<span class="err">Please complete these steps first:\n${errs.join("\n")}</span>`, "err");
          diagnostics.textContent = "generateStatements blocked: missing inputs";
          return;
        }
        setHTML("#aiOutput", "⏳ Generating draft with Gemini…", "loading");

        const payload = {
          framework: framework?.value || "IFRS",
          companyName: companyName?.value || "",
          notes: notes?.value || "",
          priorText,
          tbParsed
        };

        const res = await fetch("/.netlify/functions/generateStatements", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const raw = await res.text();
        let data = {};
        try { data = JSON.parse(raw); } catch {}

        if (!res.ok) {
          const details = [
            data.error && `Error: ${data.error}`,
            data.details && `Details: ${data.details}`,
            data.model && `Model: ${data.model}`,
            data.modelsAvailable && `Available: ${Array.isArray(data.modelsAvailable) ? data.modelsAvailable.join(", ") : data.modelsAvailable}`,
            (!data.error && raw && raw.trim().startsWith("<")) && "Server returned HTML (likely 404). Check Netlify functions path/name."
          ].filter(Boolean).join("\n");
          setHTML("#aiOutput", `<pre class="err">❌ Generation failed.\n${details || raw || "No details returned."}</pre>`, "err");
          diagnostics.textContent = `generateStatements error:\n${details || raw}`;
          console.error("generateStatements failed:", raw);
          return;
        }

        setHTML("#aiOutput", `<pre>${data.output || "No output"}\n\n(Using model: ${data.model || "unknown"})</pre>`);
        diagnostics.textContent = `generateStatements OK (model: ${data.model || "unknown"})`;
      } catch (err) {
        console.error("generateStatements exception:", err);
        setHTML("#aiOutput", `<span class="err">❌ ${err.message}</span>`, "err");
        diagnostics.textContent = `generateStatements exception: ${err.message}`;
      }
    });

    // Global JS error catcher
    window.addEventListener("error", (e) => console.error("Global JS error:", e.message));
  })();
  </script>
</body>
</html>















